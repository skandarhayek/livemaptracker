<!DOCTYPE html>
<html>
  <head>
    <title>CDT Live Tracker</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <link
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css"
      rel="stylesheet"
    />
    <link rel="icon" type="image/x-icon" href="public/favicon.ico" />
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.css"
    />
    <style>
      #map {
        height: 100vh;
        width: 100vw;
        margin: -8px;
      }
      .leaflet-marker-icon {
        background-color: transparent;
        border: none;
        box-shadow: none;
      }
      .leaflet-div-icon {
        background-color: transparent !important;
      }
      .legend {
        padding: 6px 8px;
        background: white;
        border-radius: 4px;
        z-index: 1000;
        display: block;
        margin-bottom: -12px !important;
        margin-right: 5px !important;
        bottom: 18px;
        background: white;
      }
      .legend h4 {
        margin: 0 0 5px;
        color: #777;
      }
      .legend-content i {
        width: 18px;
        height: 3px;
        float: left;
        margin: 8px 8px 0 0;
        opacity: 0.7;
      }
      #progress-container {
        position: absolute;
        bottom: 10px;
        left: 10px;
        width: 250px;
        background: white;
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 10000;
      }
      #progress-bar {
        width: 100%;
        height: 14px;
        background-color: #eee;
        border-radius: 5px;
        overflow: hidden;
        margin-top: 6px;
      }
      #progress-fill {
        height: 100%;
        background-color: #4caf50;
        width: 0%;
        transition: width 0.3s ease;
      }
      .state-progress {
        margin-top: 8px;
        font-size: 12px;
      }
      .state-label {
        display: flex;
        justify-content: space-between;
        margin-bottom: 2px;
      }
      .state-bar {
        width: 100%;
        height: 10px;
        background-color: #eee;
        border-radius: 3px;
        overflow: hidden;
      }
      .state-fill {
        height: 100%;
        width: 0%;
        transition: width 0.3s ease;
      }
      .nm-fill {
        background-color: #ff5733;
      }
      .co-fill {
        background-color: #33ff57;
      }
      .wy-fill {
        background-color: #ff33f6;
      }
      .mt-fill {
        background-color: #33fff6;
      }

      @media (max-width: 768px) {
        .leaflet-marker-icon.fas {
          font-size: 32px !important;
        }

        .leaflet-div-icon div {
          width: 12px !important;
          height: 12px !important;
          border-width: 3px !important;
        }

        #progress-bar {
          height: 18px;
        }

        .state-progress {
          margin-top: 12px;
          font-size: 14px;
        }

        .state-bar {
          height: 14px;
        }

        .leaflet-popup-content {
          font-size: 16px !important;
          line-height: 1.5 !important;
        }
      }

      .mobile-toggle {
        display: none;
        position: absolute;
        bottom: 20px;
        width: 40px;
        height: 40px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        cursor: pointer;
        font-size: 20px;
        padding: 0;
        display: flex;
        align-items: center;
        justify-content: center;
        color: #555;
      }

      #mobile-navbar {
        display: none;
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: white;
        border-top: 1px solid #ccc;
        z-index: 10000;
        box-shadow: 0 -2px 6px rgba(0, 0, 0, 0.1);
      }

      #mobile-navbar.visible {
        display: flex;
      }

      .nav-icon {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        padding: 8px;
        color: #555;
        cursor: pointer;
        transition: color 0.2s;
      }

      .nav-icon.active {
        color: #3357ff;
      }

      .nav-icon i {
        font-size: 20px;
        margin-bottom: 4px;
      }

      .nav-icon span {
        font-size: 12px;
      }

      @media (max-width: 768px) {
        #mobile-navbar {
          display: flex;
        }

        .leaflet-control-layers {
          display: none;
          position: fixed;
          z-index: 1000;
          bottom: 80px;
          z-index: 1000;
        }

        .leaflet-control-layers.visible {
          display: block;
        }

        .leaflet-control-geocoder {
          display: none;
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          z-index: 1000;
        }

        .leaflet-control-geocoder.visible {
          display: block;
          margin: 0;
          border: none;
          border-radius: 4px;
        }

        #stats-container {
          position: fixed;
          top: 30px;
          width: 250px;
          background: white;
          border-radius: 6px;
          padding: 6px 12px;
          font-family: Arial, sans-serif;
          font-size: 14px;
          z-index: 1000;
          transition: transform 0.3s ease;
          z-index: 10000;
        }

        #stats-container.visible {
          display: block;
        }

        #progress-container {
          display: none;
          z-index: 1000;
        }

        #progress-container.visible {
          width: calc(100% - 45px);
          bottom: 60px;
          display: block;
          margin: auto;
        }

        .mobile-toggle {
          display: none;
        }
      }

      @media (max-width: 768px) {
        .mobile-toggle.hidden {
          display: none;
        }
      }

      .mobile-toggle {
        display: none;
      }

      @media (max-width: 768px) {
        .mobile-toggle {
          display: flex;
          position: absolute;
          bottom: 20px;
          width: 40px;
          height: 40px;
          background: white;
          border: 1px solid #ccc;
          border-radius: 4px;
          box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
          z-index: 1000;
          cursor: pointer;
          font-size: 20px;
          padding: 0;
          align-items: center;
          justify-content: center;
          color: #555;
        }

        .mobile-toggle.hidden {
          display: none;
        }
      }

      #stats-container {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 250px;
        background: white;
        border: none;
        border-radius: 4px;
        padding: 6px 12px;
        font-family: Arial, sans-serif;
        font-size: 14px;
        z-index: 1000;
        transform: translateY(0);
        transition: transform 0.3s ease;
        z-index: 10000;
      }

      #stats-container.minimized {
        transform: translateY(calc(-100% + 40px));
      }

      #daily-stats {
        max-height: 300px;
        overflow-y: auto;
        transition: max-height 0.3s ease-out;
      }

      #daily-stats.collapsed {
        max-height: 0;
        overflow: hidden;
      }

      .daily-stat {
        display: flex;
        align-items: flex-start;
        padding: 6px 0;
        border-bottom: 1px solid #eee;
      }

      .color-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        margin-right: 8px;
        margin-top: 4px;
        flex-shrink: 0;
      }

      .stat-details {
        flex-grow: 1;
      }

      .stat-date {
        font-weight: bold;
        margin-bottom: 2px;
      }

      .stats-header {
        display: flex;
        justify-content: space-between;
        align-items: flex-start;
        position: relative;
      }

      .header-buttons {
        right: 0;
        top: 0;
        display: flex;
        gap: 8px;
      }

      .toggle-stats-btn {
        background: transparent;
        border: none;
        cursor: pointer;
        padding: 0;
        color: #666;
        width: 24px;
        height: 24px;
        display: flex;
        align-items: center;
        justify-content: center;
      }

      .toggle-stats-btn i {
        transition: transform 0.3s ease;
      }

      .toggle-stats-btn.collapsed i {
        transform: rotate(-180deg);
      }

      #stats-toggle {
        display: none;
        position: absolute;
        top: 10px;
        right: 10px;
        width: 40px;
        height: 40px;
        background: white;
        border: 1px solid #ccc;
        border-radius: 4px;
        box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        cursor: pointer;
        font-size: 20px;
        padding: 0;
        align-items: center;
        justify-content: center;
        color: #555;
      }

      #stats-toggle.visible {
        display: flex;
      }

      @media (max-width: 768px) {
        #stats-container {
          display: none;
          width: calc(100% - 40px);
          max-height: 60vh;
          overflow-y: auto;
        }

        #stats-container.visible {
          display: block;
        }

        #stats-toggle {
          display: flex !important;
        }
      }

      .leaflet-control-layers {
        font-family: Arial, sans-serif;
        font-size: 14px;
        background: rgba(255, 255, 255, 0.9);
        border-radius: 4px;
        border: none !important;
      }

      @media (max-width: 768px) {
        .leaflet-control-layers {
          font-size: 12px;
          display: none;
          bottom: 60px;
        }

        .leaflet-control-layers.visible {
          display: block;
        }

        .leaflet-control-layers-toggle {
          width: 44px !important;
          height: 44px !important;
        }
      }

      .leaflet-control-geocoder {
        display: flex;
        position: fixed !important;
        left: 50% !important;
        transform: translateX(-50%) !important;
        width: 300px !important;
        z-index: 1000 !important;
        height: 32px;
        border: none !important;
        flex-wrap: wrap;
      }

      .leaflet-control-geocoder-form {
        display: inherit;
        vertical-align: middle;
        margin: auto 0;
        flex: 1;
      }

      .leaflet-control-geocoder-form-no-error {
        flex: 1 0 100%;
        background: white;
        text-align: center;
        padding: 10px 0px;
        margin: 0px;
      }

      .leaflet-control-geocoder-alternatives {
        width: 100%;
        background: white;
      }

      .leaflet-control-geocoder-form input {
        width: 100%;
      }

      @media (max-width: 768px) {
        .leaflet-control-geocoder {
          width: calc(100% - 40px) !important;
          top: 10px !important;
          display: none;
        }

        .leaflet-control-geocoder.visible {
          display: flex;
        }
      }

      @media (max-width: 768px) {
        .legend {
          display: none;
        }

        .legend.visible {
          display: block;
          bottom: 55px;
        }
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <div id="mobile-navbar">
      <div class="nav-icon" data-target="layers">
        <i class="fas fa-layer-group"></i>
        <span>Layers</span>
      </div>
      <div class="nav-icon" data-target="search">
        <i class="fas fa-search"></i>
        <span>Search</span>
      </div>
      <div class="nav-icon" data-target="stats">
        <i class="fas fa-chart-bar"></i>
        <span>Stats</span>
      </div>
      <div class="nav-icon" data-target="progress">
        <i class="fas fa-chart-line"></i>
        <span>Progress</span>
      </div>
      <div class="nav-icon" data-target="legend">
        <i class="fas fa-map"></i>
        <span>Legend</span>
      </div>
    </div>

    <div id="progress-container">
      <div>
        Overall Progress: <span id="progress-percent">0%</span>
        <div id="progress-bar">
          <div id="progress-fill"></div>
        </div>
      </div>

      <div class="state-progress">
        <div class="state-label">
          <span>New Mexico</span>
          <span id="nm-percent">0%</span>
        </div>
        <div class="state-bar">
          <div class="state-fill nm-fill" id="nm-fill"></div>
        </div>
      </div>

      <div class="state-progress">
        <div class="state-label">
          <span>Colorado</span>
          <span id="co-percent">0%</span>
        </div>
        <div class="state-bar">
          <div class="state-fill co-fill" id="co-fill"></div>
        </div>
      </div>

      <div class="state-progress">
        <div class="state-label">
          <span>Wyoming</span>
          <span id="wy-percent">0%</span>
        </div>
        <div class="state-bar">
          <div class="state-fill wy-fill" id="wy-fill"></div>
        </div>
      </div>

      <div class="state-progress">
        <div class="state-label">
          <span>Montana</span>
          <span id="mt-percent">0%</span>
        </div>
        <div class="state-bar">
          <div class="state-fill mt-fill" id="mt-fill"></div>
        </div>
      </div>
    </div>
    <button
      id="progress-toggle"
      class="mobile-toggle"
      aria-label="Toggle Progress"
    >
      <i class="fas fa-chart-line"></i>
    </button>
    <button id="legend-toggle" class="mobile-toggle" aria-label="Toggle Legend">
      <i class="fas fa-map"></i>
    </button>

    <div id="stats-container">
      <div id="stats-summary">
        <div class="stats-header">
          <div>
            <div>
              <strong>Total Distance:</strong>
              <span id="total-distance">0 km</span>
            </div>
            <div>
              <strong>Total Elevation:</strong>
              <span id="total-elevation">0 m</span>
            </div>
          </div>
          <div class="header-buttons">
            <button
              class="toggle-stats-btn collapsed"
              aria-label="Toggle Daily Stats"
            >
              <i class="fas fa-chevron-up"></i>
            </button>
          </div>
        </div>
      </div>
      <div id="daily-stats" class="collapsed"></div>
    </div>
    <button id="stats-toggle" aria-label="Show Stats">
      <i class="fas fa-chart-bar"></i>
    </button>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet-omnivore/leaflet-omnivore.min.js"></script>
    <script src="https://unpkg.com/leaflet-control-geocoder/dist/Control.Geocoder.js"></script>

    <script>
      document.addEventListener("DOMContentLoaded", () => {
        const tracksLayer = L.layerGroup();
        const markersLayer = L.layerGroup();
        const cdtLayer = L.layerGroup();

        const map = L.map("map", {
          zoomControl: false
        }).setView([39, -106.5], 6);

        const geocoder = new L.Control.Geocoder({
          defaultMarkGeocode: false,
          position: "topright",
          expand: "click",
          placeholder: "Search for places or coordinates...",
          geocoder: L.Control.Geocoder.nominatim({
            geocodingQueryParams: {
              viewbox: "-125.0,31.0,-102.0,49.0",
              bounded: 1
            }
          }),
          collapsed: true
        });

        geocoder.addTo(map);
        const geocoderElement = document.querySelector(
          ".leaflet-control-geocoder"
        );
        if (geocoderElement) {
          if (window.innerWidth <= 768) {
            geocoderElement.style.display = "none";
          }
        }

        function haversine(coord1, coord2) {
          const R = 6371000;
          const toRad = (x) => (x * Math.PI) / 180;
          const dLat = toRad(coord2[0] - coord1[0]);
          const dLon = toRad(coord2[1] - coord1[1]);
          const lat1 = toRad(coord1[0]);
          const lat2 = toRad(coord2[0]);

          const a =
            Math.sin(dLat / 2) ** 2 +
            Math.sin(dLon / 2) ** 2 * Math.cos(lat1) * Math.cos(lat2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          return R * c;
        }

        const osmLayer = L.tileLayer(
          "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
          {
            attribution: "&copy; OpenStreetMap contributors"
          }
        );

        const topoLayer = L.tileLayer(
          "https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png",
          {
            attribution: "&copy; OpenTopoMap contributors",
            maxZoom: 17
          }
        );

        const satelliteLayer = L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
          {
            attribution:
              "&copy; Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community",
            maxZoom: 18
          }
        );

        const streetsOverlay = L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Transportation/MapServer/tile/{z}/{y}/{x}",
          {
            attribution: "Tiles &copy; Esri",
            opacity: 0.7,
            maxZoom: 18
          }
        );

        const labelsOverlay = L.tileLayer(
          "https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}",
          {
            attribution: "Tiles &copy; Esri",
            opacity: 0.7,
            maxZoom: 18
          }
        );

        const hybridLayer = L.layerGroup([
          satelliteLayer,
          streetsOverlay,
          labelsOverlay
        ]);

        osmLayer.addTo(map);

        const baseMaps = {
          Street: osmLayer,
          Topographic: topoLayer,
          Satellite: satelliteLayer,
          Hybrid: hybridLayer
        };

        const overlayMaps = {
          Tracks: tracksLayer,
          Markers: markersLayer,
          "CDT Route": cdtLayer
        };

        const layersControl = L.control
          .layers(baseMaps, overlayMaps, {
            collapsed: window.innerWidth <= 768,
            position: "topleft"
          })
          .addTo(map);

        if (window.innerWidth > 768) {
          layersControl.expand();
        }

        const navbar = document.getElementById("mobile-navbar");
        const navIcons = navbar.querySelectorAll(".nav-icon");
        const elements = {
          layers: document.querySelector(".leaflet-control-layers"),
          search: document.querySelector(".leaflet-control-geocoder"),
          stats: document.getElementById("stats-container"),
          progress: document.getElementById("progress-container"),
          legend: document.querySelector(".leaflet-control.legend")
        };

        let activeElement = null;

        navIcons.forEach((icon) => {
          icon.addEventListener("click", () => {
            const target = icon.dataset.target;

            if (activeElement === target) {
              Object.values(elements).forEach((el) => {
                if (el) {
                  if (el === elements.layers) {
                    layersControl.collapse();
                  } else if (el === elements.search) {
                    el.style.display = "none";
                  }
                  el.classList.remove("visible");
                }
              });
              navIcons.forEach((i) => i.classList.remove("active"));
              activeElement = null;
              return;
            }

            Object.values(elements).forEach((el) => {
              if (el) {
                if (el === elements.search) {
                  el.style.display = "none";
                } else {
                  el.classList.remove("visible");
                }
              }
            });
            navIcons.forEach((i) => i.classList.remove("active"));

            if (elements[target]) {
              if (target === "layers") {
                layersControl.expand();
              } else if (target === "search") {
                elements.search.style.display = "block";
              }
              elements[target].classList.add("visible");
              icon.classList.add("active");
              activeElement = target;
            }
          });
        });

        map.on("click", () => {
          Object.values(elements).forEach((el) => {
            if (el) {
              if (el === elements.layers) {
                layersControl.collapse();
              } else if (el === elements.search) {
                el.style.display = "none";
              }
              el.classList.remove("visible");
            }
          });
          navIcons.forEach((i) => i.classList.remove("active"));
          activeElement = null;
        });

        fetch("history.json?" + new Date().getTime())
          .then((res) => res.json())
          .then((history) => {
            const latestPoint = history[history.length - 1];

            setTimeout(() => {
              map.removeLayer(tracksLayer);
              map.removeLayer(markersLayer);
              map.removeLayer(cdtLayer);

              map.flyTo([latestPoint.lat, latestPoint.lon], 10, {
                duration: 1.1,
                easeLinearity: 0.25
              });

              setTimeout(() => {
                map.addLayer(tracksLayer);
                map.addLayer(markersLayer);
                map.addLayer(cdtLayer);
              }, 1100);
            }, 800);

            fetch("gpx-files.json?" + new Date().getTime())
              .then((res) => res.json())
              .then((gpxFiles) => {
                const cdtFile = gpxFiles.find((f) => f.includes("cdt.gpx"));
                if (!cdtFile) return;

                fetch("gpx/" + cdtFile)
                  .then((res) => res.text())
                  .then((gpxText) => {
                    const gpxParser = new DOMParser();
                    const gpxDoc = gpxParser.parseFromString(
                      gpxText,
                      "application/xml"
                    );
                    const trkpts = Array.from(
                      gpxDoc.querySelectorAll("trkpt")
                    ).map((pt) => [
                      parseFloat(pt.getAttribute("lat")),
                      parseFloat(pt.getAttribute("lon"))
                    ]);

                    const cumulativeDistances = [0];
                    for (let i = 1; i < trkpts.length; i++) {
                      const dist = haversine(trkpts[i - 1], trkpts[i]);
                      cumulativeDistances.push(
                        cumulativeDistances[i - 1] + dist
                      );
                    }

                    let minDist = Infinity;
                    let closestIndex = 0;
                    trkpts.forEach((pt, i) => {
                      const d = haversine(pt, [
                        latestPoint.lat,
                        latestPoint.lon
                      ]);
                      if (d < minDist) {
                        minDist = d;
                        closestIndex = i;
                      }
                    });

                    const percentComplete =
                      (cumulativeDistances[closestIndex] /
                        cumulativeDistances[cumulativeDistances.length - 1]) *
                      100;

                    document.getElementById("progress-percent").textContent =
                      percentComplete.toFixed(2) + "%";
                    document.getElementById("progress-fill").style.width =
                      percentComplete + "%";

                    const stateSegments = getStateSegments(trkpts);
                    const stateProgress = calculateStateProgress(
                      stateSegments,
                      trkpts,
                      cumulativeDistances,
                      closestIndex
                    );

                    for (const [state, progress] of Object.entries(
                      stateProgress
                    )) {
                      const stateCode = state.toLowerCase();
                      document.getElementById(
                        `${stateCode}-percent`
                      ).textContent = progress.toFixed(2) + "%";
                      document.getElementById(`${stateCode}-fill`).style.width =
                        progress + "%";
                    }
                  });
              });

            const pointsByDay = history.reduce((groups, point) => {
              const mdtDateStr = getMDTDateString(point.time);
              if (!groups[mdtDateStr]) {
                groups[mdtDateStr] = [];
              }
              groups[mdtDateStr].push(point);
              return groups;
            }, {});

            let totalDistance = 0;
            let totalElevation = 0;
            const dailyStats = [];

            Object.entries(pointsByDay).forEach(([mdtDateStr, points]) => {
              const dayColor = generateDayColor(new Date(mdtDateStr));

              let dailyDistance = 0;
              let dailyAltitudeGain = 0;

              for (let i = 1; i < points.length; i++) {
                const prev = points[i - 1];
                const curr = points[i];

                const distance = haversine(
                  [prev.lat, prev.lon],
                  [curr.lat, curr.lon]
                );
                dailyDistance += distance;

                if (prev.elev && curr.elev) {
                  const elevDiff = curr.elev - prev.elev;
                  if (elevDiff > 0) {
                    dailyAltitudeGain += elevDiff;
                  }
                }
              }

              const distanceKm = (dailyDistance / 1000).toFixed(2);
              const altitudeGainM = Math.round(dailyAltitudeGain);

              totalDistance += dailyDistance;
              totalElevation += dailyAltitudeGain;

              dailyStats.push({
                date: mdtDateStr,
                distance: dailyDistance,
                elevation: dailyAltitudeGain,
                color: dayColor
              });

              points.forEach((point) => {
                const localDate = new Date(point.time);
                const formattedDate = localDate.toLocaleDateString("en-GB");
                const dayNumber = getDaysSinceStart(point.time);
                const popupContent = `
                  <b>Day ${dayNumber}</b><br>
                  <b>Time:</b> ${formattedDate} ${localDate.toLocaleTimeString()}<br>
                  <b>Latitude:</b> ${point.lat.toFixed(6)}<br>
                  <b>Longitude:</b> ${point.lon.toFixed(6)}<br>
                  <b>Elevation:</b> ${point.elev || "N/A"}<br>
                  <b>Velocity:</b> ${point.velo || "N/A"}
                `;

                const isLatest = point === latestPoint;
                const icon = L.divIcon({
                  className: "leaflet-div-icon",
                  html: isLatest
                    ? `<i class="fas fa-map-marker-alt" style="color: orange; font-size: ${
                        window.innerWidth <= 768 ? "32px" : "24px"
                      };"></i>`
                    : `<div style="
          width: ${window.innerWidth <= 768 ? "12px" : "8px"};
          height: ${window.innerWidth <= 768 ? "12px" : "8px"};
          background-color: ${dayColor};
          border-radius: 50%;
        "></div>`,
                  iconSize: isLatest ? [32, 32] : [18, 18],
                  iconAnchor: isLatest ? [16, 32] : [9, 9],
                  popupAnchor: [0, isLatest ? -32 : -9]
                });

                L.marker([point.lat, point.lon], { icon })
                  .bindPopup(popupContent)
                  .addTo(markersLayer);
              });

              const dayPolyline = points.map((p) => [p.lat, p.lon]);
              L.polyline(dayPolyline, {
                color: dayColor,
                weight: 3,
                opacity: 0.7
              }).addTo(tracksLayer);
            });

            document.getElementById("total-distance").textContent =
              (totalDistance / 1000).toFixed(2) + " km";
            document.getElementById("total-elevation").textContent =
              Math.round(totalElevation) + " m";

            const dailyStatsContainer = document.getElementById("daily-stats");
            dailyStats
              .sort((a, b) => new Date(b.date) - new Date(a.date))
              .forEach((stat) => {
                const distanceKm = (stat.distance / 1000).toFixed(2);
                const elevationM = Math.round(stat.elevation);

                const dayElement = document.createElement("div");
                dayElement.className = "daily-stat";
                dayElement.innerHTML = `
      <div class="color-dot" style="background-color: ${stat.color}"></div>
      <div class="stat-details">
        <div class="stat-date">${stat.date}</div>
        <div>Distance: ${distanceKm} km</div>
        <div>Elevation Gain: ${elevationM} m</div>
      </div>
    `;
                dailyStatsContainer.appendChild(dayElement);
              });

            const toggleStatsBtn = document.querySelector(".toggle-stats-btn");
            if (toggleStatsBtn) {
              toggleStatsBtn.addEventListener("click", () => {
                const isCollapsed =
                  toggleStatsBtn.classList.contains("collapsed");
                const dailyStats = document.getElementById("daily-stats");

                if (isCollapsed) {
                  // Show daily stats
                  toggleStatsBtn.classList.remove("collapsed");
                  dailyStats.classList.remove("collapsed");
                } else {
                  // Hide daily stats
                  toggleStatsBtn.classList.add("collapsed");
                  dailyStats.classList.add("collapsed");
                }
              });
            }
          });

        const STATE_BORDERS = {
          NM_CO: 37.0,
          CO_WY: 41.0,
          WY_MT: 45.0
        };

        function getStateSegments(trkpts) {
          const segments = {
            NM: [],
            CO: [],
            WY: [],
            MT: []
          };

          trkpts.forEach((pt, idx) => {
            const lat = pt[0];
            if (lat < STATE_BORDERS.NM_CO) {
              segments.NM.push(idx);
            } else if (lat < STATE_BORDERS.CO_WY) {
              segments.CO.push(idx);
            } else if (lat < STATE_BORDERS.WY_MT) {
              segments.WY.push(idx);
            } else {
              segments.MT.push(idx);
            }
          });

          return segments;
        }

        function calculateStateProgress(
          stateSegments,
          trkpts,
          cumulativeDistances,
          closestIndex
        ) {
          const progress = {};

          for (const [state, indices] of Object.entries(stateSegments)) {
            if (indices.length === 0) continue;

            const stateStart = indices[0];
            const stateEnd = indices[indices.length - 1];
            const stateDistance =
              cumulativeDistances[stateEnd] - cumulativeDistances[stateStart];

            let stateProgress = 0;
            if (closestIndex >= stateEnd) {
              stateProgress = 100;
            } else if (closestIndex >= stateStart) {
              const completedDistance =
                cumulativeDistances[closestIndex] -
                cumulativeDistances[stateStart];
              stateProgress = (completedDistance / stateDistance) * 100;
            }

            progress[state] = stateProgress;
          }

          return progress;
        }

        function getMDTDateString(timestamp) {
          return new Date(
            new Date(timestamp).toLocaleString("en-US", {
              timeZone: "America/Denver"
            })
          ).toDateString();
        }

        const trackColors = [
          "#FF5733", // Orange-red
          "#33FF57", // Lime green
          "#FF33F6", // Pink
          "#33FFF6", // Cyan
          "#F6FF33", // Yellow
          "#9933FF", // Purple
          "#FF8C33", // Light orange
          "#33FFB8", // Turquoise
          "#FF3369" // Rose
        ];

        function generateDayColor(date) {
          const baseHues = [
            0, // Red
            120, // Green
            240, // Blue
            60, // Yellow
            180, // Cyan
            300, // Magenta
            30, // Orange
            270, // Purple
            150 // Spring Green
          ];

          const dayNumber = Math.floor(date.getTime() / (1000 * 60 * 60 * 24));

          const hueIndex = dayNumber % baseHues.length;
          const baseHue = baseHues[hueIndex];

          const saturation = dayNumber % 2 === 0 ? 70 : 85;
          const lightness = dayNumber % 3 === 0 ? 45 : 60;

          return `hsl(${baseHue}, ${saturation}%, ${lightness}%)`;
        }

        function formatTrackName(filename) {
          return filename
            .replace(".gpx", "")
            .split("-")
            .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
            .join(" ");
        }

        function getDaysSinceStart(timestamp) {
          const startDate = new Date("2025-04-13");
          const pointDate = new Date(timestamp);
          const diffTime = pointDate - startDate;
          const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24));
          return diffDays + 1;
        }

        fetch("gpx-files.json?" + new Date().getTime())
          .then((response) => response.json())
          .then((gpxFiles) => {
            const legend = L.control({ position: "bottomright" });

            legend.onAdd = function (map) {
              const div = L.DomUtil.create("div", "leaflet-control legend");

              const contentDiv = document.createElement("div");
              contentDiv.className = "legend-content";

              const header = document.createElement("h4");
              header.textContent = "Tracks";
              contentDiv.appendChild(header);

              gpxFiles.forEach((file, index) => {
                const color =
                  file === "cdt.gpx"
                    ? "#3357FF"
                    : trackColors[index % trackColors.length];
                const name = formatTrackName(file);

                const entry = document.createElement("div");
                const colorBar = document.createElement("i");
                colorBar.style.background = color;
                entry.appendChild(colorBar);
                entry.appendChild(document.createTextNode(name));
                contentDiv.appendChild(entry);
              });

              div.appendChild(contentDiv);

              L.DomEvent.disableClickPropagation(div);
              L.DomEvent.disableScrollPropagation(div);

              return div;
            };

            legend.addTo(map);

            const navbar = document.getElementById("mobile-navbar");
            const navIcons = navbar.querySelectorAll(".nav-icon");
            const elements = {
              layers: document.querySelector(".leaflet-control-layers"),
              search: document.querySelector(".leaflet-control-geocoder"),
              stats: document.getElementById("stats-container"),
              progress: document.getElementById("progress-container"),
              legend: document.querySelector(".leaflet-control.legend")
            };

            let activeElement = null;

            navIcons.forEach((icon) => {
              icon.addEventListener("click", () => {
                const target = icon.dataset.target;

                if (activeElement === target) {
                  Object.values(elements).forEach((el) => {
                    if (el) {
                      if (el === elements.layers) {
                        layersControl.collapse();
                      } else if (el === elements.search) {
                        el.style.display = "none";
                      }
                      el.classList.remove("visible");
                    }
                  });
                  navIcons.forEach((i) => i.classList.remove("active"));
                  activeElement = null;
                  return;
                }

                Object.values(elements).forEach((el) => {
                  if (el) {
                    if (el === elements.search) {
                      el.style.display = "none";
                    } else {
                      el.classList.remove("visible");
                    }
                  }
                });
                navIcons.forEach((i) => i.classList.remove("active"));

                if (elements[target]) {
                  if (target === "layers") {
                    layersControl.expand();
                  } else if (target === "search") {
                    elements.search.style.display = "flex";
                  }
                  elements[target].classList.add("visible");
                  icon.classList.add("active");
                  activeElement = target;
                }
              });
            });

            map.on("click", () => {
              Object.values(elements).forEach((el) => {
                if (el) {
                  if (el === elements.layers) {
                    layersControl.collapse();
                  } else if (el === elements.search) {
                    el.style.display = "none";
                  }
                  el.classList.remove("visible");
                }
              });
              navIcons.forEach((i) => i.classList.remove("active"));
              activeElement = null;
            });

            gpxFiles.forEach((file, index) => {
              const color =
                file === "cdt.gpx"
                  ? "#3357FF"
                  : trackColors[index % trackColors.length];
              const targetLayer = file === "cdt.gpx" ? cdtLayer : tracksLayer;

              omnivore
                .gpx(
                  `gpx/${file}`,
                  null,
                  L.geoJson(null, {
                    filter: function (feature) {
                      return feature.geometry.type !== "Point";
                    }
                  })
                )
                .on("ready", function () {
                  this.setStyle({
                    color: color,
                    weight: file === "cdt.gpx" ? 2 : 3,
                    opacity: 0.7
                  });
                  targetLayer.addLayer(this);
                });
            });
          })
          .catch((error) => console.error("Error loading GPX files:", error));

        const progressToggle = document.getElementById("progress-toggle");
        const legendToggle = document.getElementById("legend-toggle");
        const statsToggle = document.getElementById("stats-toggle");
        if (progressToggle) progressToggle.remove();
        if (legendToggle) legendToggle.remove();
        if (statsToggle) statsToggle.remove();

        geocoder.on("markgeocode", function (e) {
          const bbox = e.geocode.bbox;
          const poly = L.polygon([
            bbox.getSouthEast(),
            bbox.getNorthEast(),
            bbox.getNorthWest(),
            bbox.getSouthWest()
          ]);
          map.fitBounds(poly.getBounds());

          // Remove any existing search marker before adding a new one
          if (window.searchMarker) {
            map.removeLayer(window.searchMarker);
          }

          // Create and store the new marker
          window.searchMarker = L.marker(e.geocode.center)
            .addTo(map)
            .bindPopup(e.geocode.name)
            .openPopup();
        });
      });
    </script>
  </body>
</html>
